  # Roadmap

> No release planning yet. This document describes some desired features to be included soon.

*The following features are **not** yet registered as Issues on purpose, since they require more planning or detailing.*

## Compiler

1. Being able to filter files by name for test execution.
2. Being able to filter files by name for test generation without having to include dependencies.
3. Being able to filter test cases by importance number for test execution.
4. Being able to filter test cases by importance number for test generation.


## Language

1. Create a tag to disable invalid data generation for a certain UI Element property
2. Accept UI Element properties inside strings of UI Element properties
3. Accept UI Element properties inside strings from Variant steps
4. Accept UI Element properties in Variant steps
5. Support dynamic States, produced from UI Element values
6. Support Variant Background
7. Consider global UI Elements
8. Allow inheritance of UI Elements
9.  Allow table matching
10. Multi-line queries
11. Multiple declared Tables per query
12. Multiple declared Databases per query

**Details:**

### 1. Create a tag to disable invalid data generation for a certain UI Element property

This is needed when the User Interface uses a mask and blocks any invalid input value.
In such case, an invalid value is never accepted and the behavior described in a `Otherwise` sentence never happens.

Example:
```concordia
UI Element: Age
  - format is "[0-9]{1,3}"
    Otherwise I see "Please inform a number"
```

In this case, whether the UI blocks invalid input values, all the test cases that produces them could fail.

Therefore, a tag that indicates that could be used:

Example (`@valid-only`):
```concordia
UI Element: Age
  @valid-only
  - format is "[0-9]{1,3}"
    Otherwise I see "Please inform a number"
```

This will avoid generating invalid data test cases for the target property.


### 2. Accept UI Element properties inside strings of UI Element properties

Example:
```concordia
UI Element: Name
- min length is 2
  Otherwise I must see "${name} must have at least ${minlength} characters."
```

The string `"${name} must have at least ${minlength} characters."` will have:
- `${name}` replaced with `Name`
- `${minlength}` replace with `2`

Properties that could be allowed, in the format `${something}`:
- `name`;
- `id`, which default to the lower-cased `name` if undefined;
- `type`, which defaults to `string` if undefined;
- `datatype`, which defaults to `textbox` if undefined;
- `minlength`, which defaults to `0` if undefined;
- `maxlength`, which defaults to max string supported if undefined;
- `minvalue`, which defaults to minimal value supported if undefined;
- `maxvalue`, which defaults to maximum value supported if undefined;
- `value`, which will receive the value generated by the test case;


### 3. Accept UI Element properties inside strings from Variant steps

#### Example

```gherkin
Then I see "The password \"${Password|value}\" is weak."
```
which is equivalent to
```gherkin
Then I see "The password \"${Password}\" is weak."
```

### 4. Accept UI Element properties in Variant steps

#### Example

```gherkin
Then I see that {Age} is ${Age|minvalue}.
```

In the above step, `${Age|minvalue}` will be replaced by its minimum value, *e.g.*, `21`.


### 5. Support dynamic States, produced from UI Element values

Example:
```gherkin
  Given that I fill {User}
    and I fill {Pass}
    and I click  on {OK}
  Then I see "Welcome"
    and I have ~{Type} is logged in~

UI Element: User
  - value comes from "SELECT user FROM [Users]"

UI Element: Pass
  - value comes from "SELECT pass FROM [Users] WHERE user = {User}"

UI Element: Type
  - value comes from "SELECT type FROM [Users] WHERE user = {User}"


Table: Users
  | user  | pass    | type   |
  | bob   | 123456  | admin  |
  | joe   | 654321  | guest  |
  | alice | 123456  | admin  |

```

### 6. Support Variant Background

Implement `Variant Background`, which is included in Concordia Language but was not implemented yet by the Concordia Compiler.


### 7. Consider global UI Elements

Make the tool processing UI Elements tagged with `@global`.


### 8. Allow inheritance of UI Elements

Use `@extends( <name> )` to extend another UI Element.

Example:
```concordia
UI Element: Name
- min length is 2
- max length is 100

@extends( Name )
UI Element: Emergency Contact Name

# Emergency Contact Name inherits the properties from Name
```

### 9. Allow table matching

Allow a given UI Element or UI Literal to match a certain Table.

Example 1:
```concordia
Then I see the table {MyTable} as [Some Table]
```
Example 2:
```concordia
Then I see the table <myTable> as [Some Table]
```

In which `Some Table` is declared like this:
```concordia
Table: Some Table
| Name  | Age |
| Bob   | 21  |
| Suzan | 25  |
```

It should make target table's rows to match the declared ones.


### 10. Multi-line queries

Currently:
```
- value comes from "SELECT name FROM [MyDB].profession"
```
Proposal (to accept as valid):
```
- value comes from "SELECT name
                   FROM [MyDB].profession"`
```
Alternative proposal:
```
- value comes from
"""
SELECT name
FROM [MyDB].profession
"""
```

### 11. Multiple declared Tables per query


### 12. Multiple declared Databases per query


# UI and Report

- Show precessing icons while waiting

- Show percentage (bar?) being processed, according to the number of feature files

- Generate a proper report in HTML, *e.g.*, `--report html`



## Performance

### Do not regenerate tests when a feature file and its dependencies have not changed their hash

Maybe it could be used a config file with the hashes, similar (but simpler) to what `package-lock.json` does, to control features' hashes.

Example:
```json
{
  "hashes": {
    "feature1.feature": "ox10JBprHtu5c8822XooloNKUfk=",
    "subdir/feature2.feature": "DMcj5b67Albe4KhpzyvphC5nVDHn1oCO",
  }
}
```



## Security

### Generate test cases that explore SQL Injection

Use declared Databases and Queries to formulate Test Cases that generate strings with SQL Injection commands.

### Add a test case that uses naughty strings as test data

Use a [list of naughty strings](https://github.com/minimaxir/big-list-of-naughty-strings) as test data.

### Sanitize all input file names

Sanitize files such as:
- CLI input files
- Concordia Import files
- Concordia Database paths

Perhaps to use [this sanitizer](https://github.com/parshap/node-sanitize-filename)



## Tool integration

### Integration with text editors

Create new projects for auto-completion plug-ins for text editors such as VS Code, Sublime Text, Atom, etc.

*Add here some inspiring projects.*:
- VS Code: [gherkin-autocomplete](https://github.com/silverbulleters/gherkin-autocomplete)


### Integration with reporting tools

Create integration with reporting tools, such as:
- [Allure](https://github.com/allure-framework/allure2/)
- [Macaca Reporter](https://github.com/macacajs/macaca-reporter)
- (add others here)


## Internal

### Use a linter

Configure the project to use [tslint](https://github.com/palantir/tslint) or another linter with more configuration options.
